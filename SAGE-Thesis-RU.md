# Механизм систематизированной генерации атрибутов

***Механизм систематизированной генерации атрибутов*** (***systemized attribute generation engine***), или ***МСГА*** (***SAGE***) - механизм, задачей которого ставится генерация значений по заданным требованиям. Механизм использует сеть атрибутов-ограничений и контроллер для управления сетью и обработкой запросов генерации.

### Постановка задачи

Требуется разработать механизм, позволяющий задавать определённые ограничения на генерацию значений, а затем генерировать эти значения по запросам. Добавление ограничений, а также новых генерируемых значений должно быть возможным в процессе генерации значений. Ограничения на генерацию значений могут связывать различные значения друг с другом на основе тождеств, неравенств и др. Таким образом, требуется создать интерактивную систему по генерации значений, которая способна модифицировать своё состояние и генерировать значения на основе текущего состояния.

### Прелиминарии

Объект, над которым производится генерация, называется ***атрибутом*** (***attribute***). У каждого атрибута определён ***тип атрибута*** (***attribute type***), а также множество ***значений атрибута*** (***attribute tvalues***). Значения атрибута определюется как минимум типом атрибута, как максимум - типом и наложенными ограничениями.

***Ограничение атрибутов*** (***attributes constraint***), или просто ***ограничение*** (***constraint***) - правило, накладывающее определённые ограничением требования на значения некоторых атрибутов.

- Ограничение называется ***односвязным*** (***simply connected***), если в ограничении не существует требования, которое определяет зависимость двух и более атрибутов между собой;
- Ограничение называется ***многосвязным*** (***multiconnected***), если в ограничении существует требование, которое определяет зависимость нескольких атрибутов между собой. В частности, ограничение называется ***n-связным*** (***n-connected***), если в ограничении существует требование, которое определяет зависимость n атрибутов между собой, и не существует подобного для n + 1 атрибута.

Примерами односвязного ограничения являются:
- количество прыжков главного героя должно быть равно единице;
- количество прыжков главного героя должно быть в диапазоне [1, 3];
- цвет главного героя не должен быть тусклым, или формально, если цвет `color` задаётся тремя параметрами (r, g, b) от 0 до 255, то ограничение есть `color.r + color.g + color.b >= c`, где `c` - константа от 0 до 255 * 3. Заметим, что здесь `color` является одним атрибутом (возможна реализация, в которой компоненты цвета являются отдельными атрибутами, тогда ограничение не является односвязным).

Примерами многосвязного ограничения являются:
- высота прыжка и количество прыжков должны быть такими, чтобы было возможно забраться на определённую высоту. Формально, `jump_height * jump_num >= h`, где `h` - константа (двусвязное ограничение).
- общий показатель мощности аптечек и общий показатель силы противника должны балансировать в некотором пределе. Аналогично, общий показатель здоровья противника и общий показатель количества боеприпасов должны балансировать в некотором пределе. Пример формального задания - `|x - y| < c`, где `c` - константа. Вычисление показателей задаётся по-своему. Данный пример является важным с точки зрения механизма регулированися игровых балансов.

В силу того, что имеют место быть многосвязные ограничения, процесс генерации называется систематизированным, т.е. генерация каждого атрибута происходит зависимо от текущего состояния всей системы (других атрибутов и ограничений).

На практике атрибутами могут являться любые сущности. Они могут описывать здоровье монстра конкретного типа, могут описывать здоровье конкретного монстра, могут описывать потенциальное количество монстров на сцене, высоту прыжка главного героя, максимальную высоту платформ в игре, и так далее. В теории смысл атрибутов, как и использование генерирующихся значений атрибутов, не имеет значения и выходит за рамки поставленной задачи.

### Описание механизма

Для работы с атрибутами и ограничениями опишем основные сущности механизма.

##### ACN

***Сеть атрибутов и ограничений*** (***attribute-constraint net***), или ***САО*** (***ACN***) - биграф (двудольный граф), узлами которого являются атрибуты и ограничения.
- Каждый атрибут в сети определяется
	1. строковым идентификатором,
	2. типом,
	3. распределением значений.
- Каждое ограничение определяется
	1. набором шаблонов,
	2. набором идентификаторов (в том числе шаблонных идентификаторов и свёрток),
	3. предикатом.

Сеть описывает текущее состояние атрибутов и ограничений. Узлы-атрибуты в сети по сути представляют из себя набор допустимых для генерации значений и распределение этих значений для регулирования вероятностного распределения генерации. При этом текущий набор допустимых значений атрибута не хранится в узле непосредственно, а полностью определяется узлами-ограничениями сети. Все требования к значениям атрибутов лежат на ограничениях. Как уже упоминалось, ограничения имеют связь с атрибутами, на которые они накладывают требования. Если некоторое ограничение накладывает требование, в котором участвует некоторый атрибут, то между этими ограничением и атрибутом проводится ребро, таким образом и получается двудольная сеть.

Перед описанием ограничений стоит объяснить, что можно получить из данной сети. Дело в том, что (в общем случае) просто выбрать атрибут в сети и сгенерировать случайное допустимое значение по заданному распределнию не получится - атрибут может быть завязан с другими атрибутами через ограничения, и тогда генерация значения одного атрибута нецелесообразна без генерации других, связанных с ним. Простым примером может служить упомянутый, но упрощённый пример с высотой прыжка и высотой платформ. Если есть ограничение, что `jump_height >= platform_height`, то как можно сгенерировать значение `jump_height`, если мы не требуем сгенерировать значение `platform_height`, чтобы быть убеждённым в том, что ограничение выполнено? Состояние сети не должно меняться при запросе генерации требуемых значений, как вывод, генерация значения некоторго атрибута влечёт генерацию всех связанных с ним атрибутов.

###### немного формализма

Теперь более формально. Если `attr_1, ..., attr_n` - текущий набор всех атрибутов сети, то ***полным допустимым набором значений*** (***complete accepted value set***) сети называется множество кортежей `(attr_1_value, ..., attr_n_value)`, где `attr_1_value, ..., attr_n_value` перебирают все допустимые значения, т.е. такие, для которых все ограничения выполняются. При этом могут существовать поднаборы `attr_i_1, ..., attr_i_k`, где `1 <= i_1 < ... < i_k <= n`, значения которых перебираются независимо от остального поднабора (дополнения к данному поднабору) значений. Строго, если набор атрибутов `attr_1, ..., attr_k` разбивается на два (взаимно-дополняемых) поднабора `attr_i_1, ..., attr_i_k1` и `attr_i_1, ..., attr_i_k2`, `k1 + k2 = k`, таких что набор значений `(attr_1_value, ..., attr_k_value)` получается объединением двух поднаборов значений по принципу 'каждый с каждым', то такие поднаборы называются ***взаимно-независимыми*** (***mutually independent***) по отношению друг к другу, ***отделяемыми*** (***detachable***) по отношению к первоначальному набору, а первоначальный набор ***распадающимся***, или ***расщепляющимся*** (***splittable***) на данные поднаборы. Если для некоторого набора атрибутов не существует отделяемых поднаборов, то такой набор называется ***простым*** (***simple***), или ***примарным*** (***primary***). Как вывод, генерировать значения атрибутов сети можно только целым набором, являющимся отделяемым по отношению ко всему набору атрибутов сети. Тривиальными отделяемыми поднаборами атрибутов являются сам набор атрибутов сети, а также пустой поднабор.

Условие отделяемости поднабора равносильно несуществованию ограничения в сети, связвающего хотя бы один атрибут данного поднабора и один атрибут дополняемого поднабора.

###### ограничения

Как было неявно показано, основная логика заключается не в атрибутах, а в ограничениях, которые полностью управляют требованиями к значениям атрибутов. По сути ограничение может представлять из себя любую описанную формально выражением фразу, которая порождает некоторые требования к определённым атрибутам (см. примеры ограничений ранее). Поэтому каждое ограничение имеет т.н. ***предикат*** (***predicate***), который и задаёт формальное требование к атрибутам, участвующим в выражении.

Для удобства анализа предиката все атрибуты, использующиеся в выражении, описываются отдельно как ***набор атрибутов*** (***attribute set***) ограничения. Для каждого атрибута просто указывается его идентификатор в сети, затем в выражении можно использовать данный идентификатор для обозначения в выражении использования данного атрибута. Остальные значения в выражении будут являться константными значениями.

Для некоторых удобств работы с сетью процесс работы с атрибутами в ограничениях имеет более сложную структуру, в то же время дающую некоторые дополнительные, весьма полезные на практике возможности. Дело в том, что нам может потребоваться от ограничения, чтобы оно определяло требование к атрибутам, которые могут появиться позднее самого ограничения. Другими словами, представьте, что каждый вид монстров в игре имеет связанный с ним атрибут в сети, определяющий его изначальное здоровье, и что нам нужно ограничить здоровье всех монстров в игре до тысячи единиц, причём не только тех видов монстров, которые уже присутствуют в игре, но и тех, которые появятся позже (допуская, что во время игры могут создаваться новые виды). Понятно, что на момент создания ограничения мы не можем "захардкодить" атрибуты здоровья конкретных видов монстров, и тем более мы не можем "захардкодить" атрибуты здоровья видов монстров, которые ещё не введены в игру в принципе. Для этого создана следующая схема описания ограничения.

- В ограничении задаётся т.н. ***набор шаблонов*** (***template set***). Каждый шаблон представляет из себя подобие регулярного выражения, но сильно упрощённого, содержащего только константные строкове символы идентификатора атрибута и символ '*', означающий любую (непустую) строку;
- При описании атрибутов, помимо обычных атрибутов, задающихся идентификатором атрибута сети, могут задаваться ***шаблонные идентификаторы*** (***template identifier***), которые состоят из строковых символов илентификатора атрибута и одного или нескольких шаблонов из набора шаблонов. Такие идентификаторы определяют ***динамический набор атрибутов*** (***dynamic attribute set***) - набор, элементы которого определяются по требованию и могут меняться в процессе изменения состояния сети. Например, если указать шаблон `template1: "monster_type_*_"`, то идентификатор `ident1: "${template1}health"` будет перечислять атрибут начального здоровья всех монстров по их видам. Вынесение описаний щаблонов отдельно от идентификаторов нужен для возможности зависимого перебора. Рассмотрим пример предиката с двумя идентификаторами (с 'захардкоженными шаблонами'): `monster_type_*_jump_height x monster_type_*_jump_num >= 100`. По логике мы хотим указать данным ограничением, что каждый вид монстров должен быть способен допрыгнуть в итоге до высоты 100. Но два перечисления `*` никак между собой не связаны, они по факту соответствуют двум разным шаблонам, а значит, будут перебираться отдельно друг от друга, хотя в выражение они должны подставляться одинаковыми при переборе. Такой случай и называется зависимым перебором, поэтому мы создаём один шаблон `template1: "monster_type_*_"` и идентификаторы `ident1: ${template1jump_height}` и `ident2: ${template1jump_num}`, тогда предикат `${ident1} x ${ident2} >= 100` будет перебирать значения `jump_height` и `jump_num` связанно, относительно каждого вида монстра, описанного в сети.
- Есть ещё один механизм, называющийся ***свёрткой*** (***reduce***). Свёртка это ещё один особый тип идентификатора. Она описывается некоторым шаблоном и функцией, которая имеет начальное значение и которая аккумулирует (свёртывает) все найденные по шаблону значения атрибутов в одно значение, являющееся выходным значением функции. Другими словами, если шаблонный идентификатор в выражении 'плодит' множество требований, применяемых к каждому конкретному атрибуту из перечисления по шаблону, то свёртка перебирает все значения и подставляет в выражение результат свёртывающей все найденные атрибуты по шаблону функции, не создавася много требований, а подставляя в каждое требование одно и то же значение, вычисленное динамически при вызове проверки предиката. Примером использования свёртки может служить тот самый балансер, допустим, здоровья монстров и количества боеприпасов. По факту, предикат соответствует `|${total_health} - ${total_ammo}| < N`, где `N` - некоторая константа. Вопрос заключается в том, как посчитать значения двух идентификаторов. Они как раз и являются идентификаторами-свёртками: `total_health: reduce("${template_monster}health", 0, (acc, value) => acc + value)` и `total_ammo: reduce("${template_ammo_pickup}power", 0, (acc, value) => acc + value)`. Два идентификатора перебирают всех монстров на карте и все пикапы патронов на карте, высчитывая сумму здоровья и сумму всех патронов (их мощностей, т.к. у тех же пуль и ракет как патронов различная степень причинения урона монстрам). Затем эти показатели сравниваются. Примечательно, что наличие или отсутствие узлов-атрибутов в сети влияет на выполнение ограничений сети, и данный пример тому подтверждение. Иногда добавление нового монстра на карту нарушает ограничение баланса (если значения здоровья и мозности патронов на карте фиксированы), поэтому добавление нового монстра возможно только вместе с добавлением соответствующего количества патронов.

##### Netbox

***Контроллер сети*** (***net controller***), или, неформально, ***нетбокс*** (***netbox***) - аппарат, управляющий сетью, имеющий состояние и описывающий API работы с генерацией значений. Суть данного аппарата есть набор функций, содержащих примитивные команды по управлению сетью, а также непосредственное влияние на генерацию. Создание функций работы с сетью (API контроллера) решает две задачи:
- объединение одинаковых наборов команд (устранение boilerplate'ов, разбиение работы на модули);
- инкапсуляция логики работы с сетью для внешних запросов к контроллеру.

Тело функции может содержать любые вычисления, свойственные обычному языку программирования, а также работа с состоянием (чтение/запись полей) и с сетью.
- В функции нельзя создавать новые потоки/процессы, обращаться к внешним источникам данных, кроме как состоянию нетбокса и сети. Допускается вызывать в одних функциях другие, производить рекурсию;
- Состояние нетбокса есть набор ключей-значений, где ключ - строка, а значение произвольное;
- Базовые команды работы с сетью подразумевают создание узла-атрибута или узла-ограничения, генерацию значений выбранных атрибутов. Можно добавить в этот список изменение и удаление атрибутов и ограничений, но в рамках тезиса ограничимся лишь добавлением новых узлов, без изменения уже имеющихся;
- Каждая функция имеет уникальный идентификатор в виде строки;
- Фцнкции могут принимать аргументы, как фиксированного количетсва, так и произвольного (равносильно одному аргументу - списку произвольной длины);
- Набор функций является динамическим, т.е. может пополняться в процессе работы в контроллером, а именно новые функции могут создаваться в процессе вызовов других функций;
- Функции можно копировать (назначать идентификатору тело функции под другим идентификатором) и переписывать (замещать тело функции новой реализацией).

Получается, контроллер это просто набор функций над сетью и состояние, разделяемое между вызовами этих функций? И да и нет. Контроллер имеет две специальных функции инифциализации, описанных в следующем пункте. Но в остальном плане нетбокс это некоторая обёртка на сеть, чтобы внешние пользователи не работали с сетью напрямую, и чтобы структурировать работу с сетью по модулям. Пример функции, инкапсулирующей бизнес-логику игры, следующий. Пусть имеется функция, создающая новый вид монстра - `createNewMonster()`. Функция создаёт узлы-атрибуты `monster_type_i_color`, `monster_type_i_damage` и `monster_type_i_health`, где `i` есть новый номер для вида монстра, который можно хранить в состоянии нетбокса и инкрементировать после создания нового вида. На выход функция возвращает номер `i`. Для простоты будем считать, что эти атрибуты полностью описывают вид монстра. При этом пусть функция создаёт новый специальный атрибут - `monster_i_color_dep`, который является одним из следующих значений: `damage`, `health` или `none`. `monster_i_color_dep` показывает, от чего будет зависеть (каким-то описанным образом) цвет монстра - от величины урона, здоровья или ни от чего. При создании всех атрибутов функция сразу же просит сеть сгенерировать случайное значение атрибута `monster_i_color_dep` и после зафиксировать его (создать ограничение на равенство `monster_i_color_dep` возвращённому значению). После фикчации нужно вызвать (заранее-написанную) функцию, которая реализует выбранную зависимость цвета, т.е. создаст ограничение, которое определяет зависимость цвета от выбранного атрибута, либо не создат ничего при значении зависимости `none`. Создавать отдельный атрибут `monster_i_color_dep` (а не сразу выбирать в функции зависимость и вызывать другую функцию) может потребоваться в случае, если потом извне может поступить запрос на выдачу выбранной зависимости цвета, например, для отладки игры и вывода на экран. Таким образом, один вызов `createNewMonster()` содержит в себе некоторую логику, скрытую от внешний потребителей механизма, в данному случае функция неявно создаёт `monster_i_color_dep`, выбирает из него значение и создаёт произвольную зависимость цвета, при этом не нарушая основную задачу функции - создать новый вид монстра.

В заключение нужно сказать, что не обязательно размещать все атрибуты, присутствующие в игре, в ACN. Сетью нужно пользоваться тогда, когда нужно работать с генерацией значений, как вывод, если в каокм-то месте в игре не требуется генерация, то работа со значениями не должна предполагать задействование механизма SAGE, а если атрибуты не генерируются, но участвуют в определении ограничений на генерирующиеся атрибуты, то их можно передавать в нетбокс как входные аргументы некоторым функциям.

##### Процесс работы с механизмом

Осталось разобраться с тем, как использовать данный механизм, попутно введя последние определения.

1. На первом шаге создаётся сеть, состоящая из атрибутов и ограничений, которые должны присутствовать в игре в любом случае, т.е. задаются те атрибуты, бех которых игра не может обойтись, и те ограничения, которые связаны с логическими требованиями к начальным атрибутам. Также наряду с данной сетью задаётся и начальный нетбокс сети. Такая начальная сеть называется ***аксиоматической сетью*** (***axiomatic net***), а нетбокс - ***начальны*** (***initial***). Узлы аксиоматической сети и функции начального нетбокса называются ***первичными*** (***primary***). Примерами узлов аксиоматической сети могут являться высота прыжка главного героя и ограничение на высоту прыжка не меньше заданной величины. Примером первичной функции может являться упомянутое создание нового вида монстров, а именно создание определённых атрибутов монстра, таких как здоровье, скорость и др. Как пример не первичного атрибута можно привести атрибут, определяющий зависимость цвета монстра от некоторого его базового параметра, который был приведён в примере ранее. Данный атрибут не является первичным, потому что никак не влияет на базовую логику игры, в том смысле что от чего бы не зависел цвет монстра, механику игры это не сломает, в отличии от, например, атрибута здоровья монстра, без которого игра явно не может быть полноценной в желаемом для разработчика плане. Более конкретно, начальный нетбокс состоит из набора первичных функций, а также трёх ***инициализирующих функций*** (***initializing functions***):
	- Первая инициализирующая функция начального контроллера называется ***построитель***, или, неформально, ***билдер*** (***builder***). Данная функция запускается в самом начале и занимается созданием первичных атрибутов и ограничений, а также инициализацией состояния нетбокса и созданием первычных функций. Таким образом, аксиоматическая сеть создаётся не напрямую вне механизма, а через задание команд в построителе и запуске данной функции. Построитель на выход возвращает булево значение, указывающее, успешно ли выполнено создание аксиоматической сети. Важным моментом является то, что построитель - ***детерминированная функция*** (***deterministic function***), т.е. при её вызове получается всегда одна и та же аксиоматическая сеть и одно и то же начальное состояние нетбокса;
	- Вторая инициализирующая функция начального контроллера называется ***развёртыватель***, или, неформально, ***деплоер*** (***deployer***). Данная функция запускается после построителя и занимается технически теми же вещами - созданием атрибутов, ограничений, модификацией состояния нетбокса и созданием дополнительных функций нетбокса. Если построитель задаётся первычные элементы, завяданные на механике игры, то развёртыватель задаёт вторичные функции, которые влияют на качество генерации значений атрибутов, т.е. развёртыватель провязывает аксиоматическую сеть и нетбокс дополнительными служебными элементами, которые способствуют генерации. Развёртыватель так же есть детерминированная функция.
	- Третья инициализирующая функция начального контроллера называется ***запускатор***, или, неформально, ***лаунчер*** (***launcher***). Запускатор завершает процесс инициализации сети для дальнейшей работы с ней, при этом он не обязан быть детерминированным, скорее, наоброт, в запускаторе производятся все недетерминированные процессы инициализации. Опять же, технически запускатор может порождать новые атрибуты, ограничения, изенять состояние нетбокса, задавать новые функции и т.д. При этом он имете право производить недетерминированные вычисления, например, генерацию и использование значений служебных атрибутов.

Каждое выполнение функции инициализации соответствует одной из трёх соответствующих инициализирующих стадий ***построения*** (***building***), ***развёртывания*** (***deployment***) и ***запуска*** (***launching***).

Для примера работы ициниализирующих функций возьмём уже разобранный пример про создание нового монстра на сцене и определения зависимости цвета монстра от атрибута здоровья, урона или ни от чего, но немного поменяем логику - атрибут зависимости цвета от базового параметра монстра будет определяться не для каждого монстра отдельно, а для всех сразу.
- На этапе построения должна задаваться функция создания нового монстра, т.е. данная функция является первичной. В принципе, в рамках данного примера первичных атрибутов и ограничений нет, так как создание атрибутов монстра не производится в самом начале в общем случае, но если в игре обязаны присутствовать заранее продуманные монстры (например, боссы), то после определения функции можно вызвать данную функцию для создания требуемых обязательных монстров, и тогда атрибуты и ограничения начальных монстров будут первичными. Важно отметить, что функция создания монстра реализуется на данном этапе как создание только атрибутов цвета, здоровья и урона (в рамках разобранного ранее примера).
- На этапе развёртывания сначала создаётся служебный атрибут `monster_color_dep`. Затем переопределяется функция создания нового монстра, а именно старая функция копируется под другой, служебный идентификатор (под служебным здесть нужо понимать идентификатор, который не будет известен внешним пользователям механизма), а новая реализация будет вызывать старую в самом начале работы. После вызова старой функции создания монстра в новой реализации используется атрибут `monster_color_dep`, который, как уже упоминалось, не влияет на механику игры, но влияет на генерацию значений. Под использованием `monster_color_dep` после создания монстра подразумевается вызов функции создания требуемого ограничения на зависимость цвета от потенциального параметра в `monster_color_dep`. Больше никаких действий на данном этапе не выполняется.
- В заключительном этапе (запуска) проиводится генерация значения `monster_color_dep` и создание ограничения на равенство атрибута сгенерированному значению. Если на сцене есть начальные монстры (например, созданные в первом этапе), то нужно сэмитировать вызов привязки зависимости цвета от выбранного параметра, как будто монстры создавались с уже переопределённой функцией создания нового монстра, где (на втором этапе) прописана логика работы с `monster_color_dep`. Вообще, рекомендуется выносить создание монстров на третью стадию по возможности, чтобы не заморачиваться с подобными вещами, хотя это несколько нарушает концепцию стадий инициализации.

Функции инициализации вызываются по порядку. После запуска механизм SAGE готов к использованию со стороны внешних пользователей механизма.

### Реализация

#### Контроль ACN

**TODO**

#### Резолюция ограничений

**TODO**

#### Язык предикатов

Как уже известно, каждое ограничение имеет свой предикат, который интуитивно и формально определяет смысл ограничения. Для формального описания предиката требуется соответствующий инструмент. С одной стороны, должна сохраняться читаемость, или, более обще, смысл предиката, то есть его задание должно быть выразительно - примерно так, как было представлено в примерах за всё это время. С другой стороны, для работы с предикатом механизму требуется весьма явная формальная структура, удобная для анализа машиной. Сами по себе эти два требования определяют одно решение, которое буквально создано для такого рода задач - создание языка программирования. Разумеется, данный язык должен решать только поставленные задачи, в которые не входят задачи обычного языка программирования, т.е. написание произвольных тьюринг-полных программ. Сам язык как таковой предполагает решение первого пункта - удобности написания предикатов пользователями механизма; эффективность работы с предикатом для механизма, наровне с удобным для анализа машиной представлением предиката, полагается на компилятор и виртуальную машину языка. Несомненно, это самая сложная техническая часть механизма, а от качества её реализации зависит эффективность и широта использования механизма как такового.

##### Описание языка

Чтобы понять, как может и как должен выглядеть язык предикатов, определим некоторые требования.

Первое, что стоит заметить - предикат принимает на вход значения атрибутов и возвращает булевское значение - результат предиката, определяющий, удовлетворение ограничения атрибутами. Сответственно, формат входных параметров и тип выходного значения определены заранее. Как мы покажем позже, выдача предикатом на выходе булевского типа даёт возможность для специальной оптимизации в некоторых случаях.

Во-вторых, предикаты - чистые функции, т.е. не имеют побочных эффектов при выполнении, а также являются детерминированными функциями. Соответственно, В языке не имеет смысла предоставлять возможность использования print'ов и random'ов (разве что первое может использоваться для отладки).

В-третьих, предикат на данный момент выполняется искллючительно однопоточно, в целях не усложнять разработку. В любом случае, предоставлять внутри языка возможности многопоточности и многопроцессорности мы не будем.

В остальном плане предикаты могут писаться как обычные функции. Более того, мы не запретим реализовывать вспомогательные функции, при условии, что они удовлетворяют тем же требованиям, что предикаты, разве что входные и выходные параметры не предопределены. Нужно понимать, что в создание языка не входит разработка некоторого 'умного' синтаксиса или синтаксического сахара - данные введения полезны для 'полных' языков программирования, на которых пишут произвольные программы, но в нашем случае это излишне.

В принципе, на этом можно было бы закончить приближённое описание требований, но есть один важный и необычный нюанс. Так как мы проектируем язык для предикатов, которые в дальнейшем используются на этапе генерации значений атрибутов, то требования к языку могут разниться от того, какой алгоритм генерации мы используем. Хоть алгоритмы генерации атрибутов ещё и не обсуждались, достаточно знать, что их может быть некоторое количество, причём которое потенциально может возрасти в будущем, в случае если для механизма откроется новый алгоритм. В таком случае язык должен быть гибким в том плане, что он должен поддерживать различные формы, каждая из которых предполагает некоторые ограничения на язык, в силу чего предикат, удовлетворяющий определённым формам языка, может быть использован вместе с определёнными алгоритмами генерации, которые требуют принадлежность к этим формам. Как вывод, появляются т.н. ***предикатные формы*** (***predicate forms***).

Перечислим некоторые из предикатных форм. Для удобства обозначим за $L$ язык предикатов, не имеющий каких-либо специфичных ограничений, хоть мы еще и не описали строго сам язык.

1. Предикат удовлетворяет ***базовой предикатной форме*** (***base predicate form***), ***БПФ*** (***BPF***), если он написан на языке $L$. Другими словами, любой корректный предикат удовлетворяет базовой предикатной форме.
2. Предикат удовлетворяет ***дизъюнктивной нормальной предикатной форме*** (***disjunctive normal predicate form***), ***ДНПФ*** (***DNPF***), или просто ***дизъюнктивной предикатной форме*** (***disjunctive predicate form***), если он удовлетворяет базовой предикатной форме и не содержит циклов и рекурсивных вызовов функций. В частности это касается всех потенциальных вспомогательных функций, таких как, например, вычисление квадратного корня или синуса. Может показаться удивительным, но предикат, который удовлетворяет ДНПФ, может быть представлен как дизъюнкция конъюнкций некоторых выражений.
3. Предикат удовлетворяет ***линейной предикатной форме*** (***linear predicate form***), ***ЛПФ*** (***LPF***), если он удовлетворяет дизъюнктивной предикатной форме и содержит только линейные (относительно атрибутов) выражения, т.е. вида $const_1 * attr_1 + \ldots + const_n + attr_n$. Может показаться, что константы здесь - это заранее введённые числа, но это не совсем так. Константы здесь могут быть даже вызовами вспомогательных функций и что-то считать, но они не должны зависеть от значений атрибутов, но так как значения атрибутов являются единственными входными параметрами предиката, все подвыражения, которые не содержат их вхождений, могут быть вычислены заранее, а значит, можно в конечном/usr/share/applications/org.kde.konsole.desktop итоге придти к действительно константным значениям в линечных выражениях.

**TODO**

##### Компилятор

**TODO**

##### Виртуальная машина

**TODO**

#### Генерация значений

**TODO**